网络连接的过程：
首先，服务端先启动监听一个端口号
状态为LISTEN
其中监听对应的端口的目的，就是未来主机收到数据包，目标端口号9999，就知道这个消息给谁
此时，如果通过netstat -natp去查看，会看到对应端口为LISTEN状态，其次，其中还有两个队列，sendQ，RecvQ

那么这里就要思考一个问题：
LISTEN状态的服务器，listen scoket的接受、发送队列中放的是什么？
connection refuse

服务端与客户端通过TCP三次握手建立链接是在内核空间建立的，此时我们的程序还不知道有这回事，这些socket就是存放在服务端的accpect队列中的，
这个队列也有大小的限制，back log，就是最大允许你存放多少个，我们的程序，或者说我们的用户空间，从这个accept队列中取相关信息，这种取的过程，是要经过IO的
BIO\NIO\多路复用等等，都有可能
back log是可以根据程序取出的速度等，来调整

connection refuse
这个问题，除了是因为网络抖动，服务没启动这些情况外
还有可能就是accept满了，用户空间的程序处理跟不上链接的速度了，导致交互卡顿，这个时候，可以根据程序的处理速度，综合考虑需不需要调整对应的accept队列的 backlog大小

服务端启动之后，客户端要连接上服务端，就需要通过三次握手 


TCP三次握手
TCP的三次握手，发生在内核空间
我们知道，网络七层分为应用层，表现层，会话层，这三层构成了用户空间
剩下的四层，传输层，网络层，数据链路层，物理层构成了内核空间
内核空间与用户空间通过IO进行传输
TCP的三次握手，客户端首先向服务端发送SYN,自己状态变更为syn-send，服务端接收到后，返回ACK确认，并且自己的状态变更为syn-rcvd,客户端接收到服务端的返回后，此时实际上已经链接成功了，
状态变更为ESTABLISHED，客户端再向服务端发送ack确认连接成功，服务端自己的状态也比变更为ESTABLISHED
三次握手成功，建立链接后，socket存储在accept队列中，服务端的用户空间，可以通过不同的IO模型，比如BIO的方式，阻塞等待accept队列中存在链接后，就去获取；也可通过NIO的方式，调用有或没有都直接返回
还可以通过多路复用的方式，不论是select,Poll或者epoll，都是其中的方式

如果在服务端返回给客户端ack之后，客户端没有返回给服务端ack，那么这个时候就是半连接。在分布式环境下叫DDOS,肉鸡的攻击，就可以这么玩
accept是正常连接才会存入其中

backlog满了，或者accept满了，新客户端直接connection refuse



TCP的四次挥手
客户端先发送一个断开链接信息给服务端，此时客户端的状态为fin-wait1
服务端接收到断开信息后，返回给客户端ack,并且自己的状态变更为close-wait状态
客户端接收到服务端返回的断开确认信息后，状态变更为fin-wait2

接着，服务端也向客户端发送一个断开链接的信息，并且自己的状态变更为LAST—ACK
客户端接收到服务端的断开链接信息后，会返回ack给服务端，并且自己的状态变更为time-wait，这个状态会通常持续时间会稍微长一些，通常是两个数据包返回的毫秒数，
服务端接收到ack后，状态变更为CLOSE 
客户端在第二次的TIME-WAIT状态之所以会等待2个数据包的毫秒数，是因为客户端返回给服务端ack之后，不会在等待服务端的返回了，这个时候，可能会丢包，导致服务端任务客户端长时间没有响应，
所以就会重试，重新发送断开信息，所以等待2个数据包的毫秒数，以处理这种情况的发生，但是还有可能及时等待了2个毫秒数，也有可能丢包，如果客户端因为丢包，导致服务单长时间没有接收ack，他最终也会断开链接


基于这些状态的变更，我们可以通过判断网络链接的各种状态，判断出具体是哪个环节出现了问题
比如，出现大量的CLOSE-WAIT的状态，就有可能是服务端接收到对应的断开信号后，只是向客户端返回了ack，而并没有真正去执行断开的操作
尤其是一些短链接，客户端申请不同的 端口号与服务端建立链接，但是服务端因为没有正确的关闭，不仅是服务端的资源没有释放，同时客户端的资源也会被消耗，端口也被消耗。
时间一长，就可能出现链接不上的情况


一定要明白：
socket有两种：
一种是服务端监听的socket
能得到的是客户端的连接，通过server.accept()这样的 方式来得到的
得到之后，会维护成一个队列，accept队列，由backlog大小控制，可以在内核配置，也可以在程序接口上进行配置

另外一种，是连接的socket（服务端的accept()，客户端的connect()）,得到的是数据，发送数据



长连接与短连接
TCP是长链接吗？
首先，长短链接和TCP没有关系，TCP只是连接而已， 连接怎么使用的，受应用层协议，双方的会话啊，协议层控制来决定长短链接
 
长短连接的本质区别，就是连接是不是一个"复用"载体
比如：
Http1.0，1.1没有开启keepalive会话保持，连接只负责一次同步阻塞的请求+响应，这个叫做短连接
Http1.0，1.1开启了keepalive会话保持，这个是同步的复用连接，即可以多次请求+响应，这个是长连接 这个是无状态的通信
dubbo的RPC协议，打开连接，可以同步或异步复用连接，即可以多次同步+响应，也可以请求，请求，响应，响应，当复用连接的时候，如果是多次请求，请求，再响应响应这种情况，那么就需要消息id，
通过消息ID保证响应和请求的是对应的，并且需要客户端和服务端同时完成这个约定，这个也被称为有状态的通信



IO模型
首先：IO是程序对内核的socket-queue的包装
BIO：读取，一直等待queue有结果才返回，阻塞模型，每连接对应一个线程
NIO:nonBlock 读取，立刻返回，有两种结果，读到或者没读到，需要程序自己去维护
多路复用器：内核增加select,poll,epoll新增的和数据接收的，连接接收实质无关的调用，得到的是对应socket的事件（listen-socket,socket），
可以有效的去再次accept，或则R/W（即程序中可以更加有效的进行读写）

同步阻塞，同步非阻塞
BIO/NIO/多路复用器，在IO模型上都是同步的，都是程序自己accept,R/w
阻塞还是非阻塞，取决于是不是等待

粘包，连包，拆包
必须要明白，对于计算机，有内核，有程序，程序和内核是协调工作的
有一些是内核做的事情，包括TCP的三次握手，数据发送出去，接收进来，都是内核做的事情
在传输的时候，TCP，肯定是分包的，会把大文件拆成很多的小包，这里面就会有粘包，连包，拆包的一个过程
他会把从网卡的buffer区里面切出来，是归属于哪个socket队列里面的

到程序里面，即便是在一个socket里，也有可能收到多个消息在一个自己数组中，我们要自己拆解（拆包）






