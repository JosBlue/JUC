#Linux
## Linux中一切皆文件
##### Linux中所有信息，都可以使用文件描述符进行查看 fd，既然是文件，则就会有输入输出操作（I/O） 

##### 任何程序都有===》0:标准输入，1:标准输出,2:报错输出；

##### $$:这是一个及其特殊的环境变量，表示当前bash的pid，也可以使用$BASHPID进行查看，当然，两者是有一定区别的
##### /proc 映射内核中的变量属性等等，比如可以看到的数字，就是进程id号；Linux一切皆文件，所以所有信息都可以被映射成文件
##### /proc/$$/fd：该命令可以查看当前进程下所有的文件描述符，还可以使用命令：lsof -op $$ 来查看这些描述符的细节，但是该命令的权限比较高，只有root权限才可以使用

##### '>' '<' 重定向操作符：这不是一个命令，而是一种机制；下面举例说明
###### 如：ls ./ 1> ls.out ：该条命令的意思就是：将./这个目录下的所有信息，输入到ls.out这个文件中，控制台将不会再输出信息
###### 如：cat app.log：该条语句有两个流操作，现将app.log中的信息输入到cat中，cat获取到后，再通过输出流输出来，咱们可以改造，将其输出到指定的文件中，如下：
###### cat 0< app.log 1> 123.log :即cat的标准输入来自于app.log，其标准输出到123.log。

##### 管道
###### 我们模拟一个需求：需要读取app.log当前文件的第8行，我们知道，读取文件的方法可以如下操作：
###### head app.log:默认读取文件的前10行信息;  head -1 app.log:读取文件的第一行； head -3 app.log:读取文件的前3行
##### tail app.log:默认读取文件的后10行信息；tail -1 app.log:读取文件的最后一行
##### 我们想要直接读取第8行的数据，则可以使用管道操作：
###### head -8 app.log ｜ tail -1 （通过head读取app.log的前8行数据，再通过管道交给tail操作，最后通过tail读取最后1行，这样就实现了只读取第8行的操作）
##### 由此，我们得出管道的基本特征，即管道前面的输出会作为管道后面的输入

##### 注意：管道踩坑：
###### 由于Bash对命令是解释执行的，因此，在使用管道的时候，管道左侧是启动了一个子进程在执行，然后再通过管道传输给右边的进程，由于是启动的子进程，因此就会存在一些问题。
> 如：我们先执行 a=1；
>然后输出：echo $a；此时他的输出值为:1
>接着，我们执行一个代码块，并通过管道输出：{a=9 ; echo 'sds';} | cat
>此时，输出的值为：sds
>我们再执行：echo $a；此时他输出的值为：1，而不是9
>原因：就是我们开头说的那一句话，由于Bash对命令是解释执行的，因此，在使用管道时，管道左侧是启动了一个子进程进行执行，在Linux中，子进程与父进程是严格隔离的。
>因此，子进程对a的改变，并不会影响父进程中的变量，所以输出的还是1
>但是，有一种特殊情况，如：我们通过管道输出当前进程id（假设父进程id为：932；子进程id为995）：echo $$ | cat
>输出的进程id为：932
>按照我们之前的理解，管道的左侧是新起的一个子进程，那么应该输出子进程id 995才对啊，为什么输出了父进程的id呢
>是因为 '$$'的优先级比管道的优先级高，所以执行的语句，先看到的是echo $$，而不是管道了，所以就直接输出父进程的id
>那么通过管道是否可以输出子进程的id呢，答案是可以的,通过：echo '$BASHPID' ｜ cat ；输出子进程id：995


##### PageCache
>  
  




















