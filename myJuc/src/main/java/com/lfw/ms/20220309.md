zk的ZAB协议

zk的会话超时、回收
分桶策略 
zk将会话将按照不同的过期时间间隔进行划分，超时时间相近的将被分到同一个桶中，随着时间的推移，过期的会话在一个桶中，然后zk会有
专门的线程，去清理这些桶。剩下的就是还未过期的。
zk的会话管理，就是队列这个数据结构
在 zk中，一个过期队列由不同的 bucket 组成。
首先，ZooKeeper 服务会开启一个线程专门用来检索过期队列，找出要过期的 bucket，
而 ZooKeeper 每次只会让一个 bucket 的会话过期，
每当要进行会话过期操作时，ZooKeeper 会唤醒一个处于休眠状态的线程进行会话过期操作，之后进行过期操作。

在zk的底层实现中，就是ExpiryQueue这个类来实现会话的过期策略
ZooKeeper 服务没有时刻去监控每一个会话是否过期。而是通过 roundToNextInterval 函数将会话过期时间转化成心跳时间的整数倍，
根据不同的过期时间段管理会话。
roundToNextInterval也就是计算出 bucket 时间区间。

在SessionTrackerImpl 的run方法中；
最后调用 expire 方法进行会话清理工作。
首先通过 close 函数向整个 ZooKeeper 服务器发起一次会话过期的请求操作。
接收到请求后，ZooKeeper 就会执行诸如删除该会话的临时节点、发起 Watch 通知等操作。

readWriteLock
HashMap hash put 
CurrentHashMap

reentranlock的公平锁是怎么实现的
在reentranlock的构造方法中，可以传入一个boolean的参数，如果为true就是调用创建公平锁的构造方法，否则默认就是非公平锁
公平锁和非公平锁的底层实现，就是差了一个hasQueuePredecessors这个方法判断，非公平锁不需要判断，如果当前资源已经被占用，那么就只能在队列中等待
当占用资源的线程释放锁之后，大家一起争抢，谁抢到算谁的，并不是你先来就是你的
但是公平锁，线程来了以后，先判断队列是否 为空，为空，就直接获得资源，不为空，就插入链表的尾部，等占用资源的线程释放锁之后，从头部开始取，先到的就有限获取资源，这样就实现了公平
总结就是：
公平锁就是在获取锁之前会先判断等待队列是否为空或者自己是否位于队列头部，该条件通过才能继续获取锁。


线程间的通信
ThreadLocal
SpringAOP实现原理
Spring如何解决循环依赖
Spring容器创建的过程
spring的事务，隔离级别有哪些
服务的熔断、降级底层原理
JVM怎么判断垃圾是可被回收的
JVM的根可达算法中，哪些可以被当作根
JVM的G1垃圾回收器
分布式事务的实际使用
mysql的聚簇索引与非聚簇索引区别是什么，底层是怎么存储的
dubbo的服务组件有哪些
多线程中线程池的重点参数，怎么创建
sync与lock

readLock有什么问题？
已经被加过锁的机器被重启了，那么就可能让这个redis被其他线程重新加锁
解决这个问题的办法：延迟启动，如24小时再重启



ZK的锁有什么问题？
相较于Redis实现锁的性能要低一些，因为有2pc的过程，并且频繁的创建和删除节点，相较于redis而言，性能也较差


zk的羊群问题？
羊群效应就是 一个特定的znode 改变的时候ZooKeper 触发了所有watches 的事件。
举个例子，如果有1000个客户端watch 一个znode的exists调用，当这个节点被创建的时候，将会有1000个通知被发送。
这种由于一个被watch的znode变化，导致大量的通知需要被发送，将会导致在这个通知期间的其他操作提交的延迟。
因此，只要可能，我们都强烈建议不要这么使用watch。仅仅有很少的客户端同时去watch一个znode比较好，理想的情况是只有1个。

CurrentHashMap底层实现？
最大线程数与队列的关系

String为什么是不变的？

MVCC机制存在什么问题

RocketMq如何保证高可用的？
RocketMq如何保证高吞吐的？
RocketMq的消息是有序的吗？
RocketMq的消息局部顺序是如何保证的?
RocketMq事务消息的实现机制？
RocketMq会有重复消费的问题吗？如何解决？
RocketMq支持什么级别的延迟消息？如何实现的？
RocketMq是推模型还是拉模型？
Consumer的负载均衡是怎么样的？










