HashMap相关：

首先map，是key,value结构
三种常见的Map
HashMap：key唯一，value不唯一，且无序
HashMap允许传入空值的key及value


LinkedHashMap：有序的HashMap 速度快

TreeMap：有序，但是速度没有hash快
基于红黑树进行实现

HashTable value不允许存储null值

1、HashMap的底层数据结构
1.7 内存地址连续的数组+链表
1.8 内存地址连续的数组+链表，数组长度大于等于8之后，链表转换为红黑树



2、为什么HashMap扩量的为2次幂（两倍）
HashMap的线程不安全的，Hashtable是线程安全的
HashMap的默认初始值大小为16，Hashtable的默认初始值大小为11
Hashtable将默认初始值设置为11，是因为它更加关注值的均匀分布，以减少hash冲突，11是一个素数，简单取模哈希的结果会更加均匀，
之前也有一本书里面写过这么一句话，大致意思就是素数取余会更加均匀
HashMap将默认值初始值设置为16，2的N次幂，这么做是因为HashMap可以提升hash计算的速度，其中进行位运算，位运算相较于直接取模会更快  
同时，在HashMap添加数据，扩容的时候，2的N次幂，更加有利于扩容时，新的key值计算，比如我们从16扩容至32，那么就是首位加1，
这个时候计算元素的新位置时，就直接元素原位置+16就可以得出新的位置，这样可以大大提升效率。当然，这种改动，也会增大hash冲突
的概率，因此又对取值时的计算进行了一些改动。
所以总而言之，就是他们的侧重点不太一样，Hashtable更加关注数据的均匀分布，HashMap则更加侧重于计算效率。

原因：
1、方便我们快速计算出数据应该放的地址值（与运算相对于直接的取模运算更快）
2、扩容后，涉及到旧元素的迁移过程，迁移的时候，只需要判断二进制的前一位是0或者是1即可，如果为0，则表示新数组元素与旧数组元素下标位置一致，如果是1，只需要将索引加上旧
数组的长度值，即为新数组的下标，这也是使用二的n次幂所带来的好处，总结而言就是方便快速计算出新的位置


3、为什么扩容后，是红黑树，而不是AVL树
平衡二叉树在插入或者删除节点时为了保证左右子树的高度差会进行旋转，这一个旋转根据数据的不同旋转的复杂度也会不一样，
所以在插入或者删除平衡二叉树的节点时，旋转的次数不可知，这也导致在频繁的插入、修改中造成的效率问题；
红黑树在执行插入修改的操作时会发生旋转与变色（红变黑，或者黑变红）以确保没有一条路径会比其它路径长出两倍。
总体来说，在插入或者删除节点时，红黑树旋转的次数比平衡二叉树少，因此在插入与删除操作比较频繁的情况下，选用红黑树。


4、红黑树插入的时间复杂度
O(logN)

5、解决Hash冲突的方式
JDK1.7 构造成链表
JDK1.8 数组长度小于8，链表，大于8，红黑树

6、与HashTable的异同
HashMap的线程不安全的，Hashtable是线程安全的
HashMap的默认初始值大小为16，Hashtable的默认初始值大小为11
HashMap是线程不安全的，效率较高，key和value都可以为空
HashTable是线程,效率相对较低，key和value都不可以为空

7、允许为null键的map你知道哪些
HashMap


8、为什么HashMap在JDK8的时候，要进行树化？
泊松分布


9、HashMap的put、扩容等操作
见图
