mysql 基础
一、mysql的基础架构
>>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/mysql的基础架构.png) 

mysql的基础架构中的组成部分，包括：
客户端
连接器
分析器（词法分析，语法分析）
优化器
执行器
存储引擎

（1）连接器：
主要负责和客户端建立连接，获取权限，维持和管理连接
连接可以分为两类：长连接与短连接

（2）分析器：
包括词法分析，语法分析，判断sql是否符合mysql的语法规则，词法分析，对sql提取关键词，比如提取where、from等关键词，组成AST（抽象语法树）

（3）优化器：
对执行sql进行优化，比如在存在多个索引时，选择提取行最少的索引，多表关联时，决定表的连接顺序。
不同执行方式对于sql的影响很大，整体而言，优化器主要从两个方面进行优化：
RBO：基于规则优化
CBO：基于成本优化

（4）执行器：
执行器主要与存储引擎一起执行sql查询，返回查询结果

（5）存储引擎
在mysql中，存储引擎主要有两个：
Innodb与MyISam
两者的区别：
（1）是否支持事务
Innodb支持事务
MyISam不支持事务

（2）锁
Innodb支持表锁和行锁
MyISam仅支持表锁，不支持行锁

（3）索引类型
Innodb是聚簇索引，即数据与索引放在一起
MyISam为非聚簇索引，数据与索引分开存储。叶子节点存储的是数据的地址，通过索引找到对应的数据地址后，还需要通过地址找到实际的数据
因此相对而言，Innodb数据查找，会少一次IO

（4）适用场景
MyISam存储引擎适用于大量查询的系统
Innodb则适用与包含增删查改的系统

mysql默认的存储引擎是Innodb


二、mysql的日志:Redo log & Undo log & binlog

mysql中的日志包括错误日志，查询日志，慢查询日志，事务日志以及二进制日志
接下来马上要理解的，就是事务日志（Redo log & Undo log） 与二进制日志（binlog）

综述  
binlog是归档日志，是mysql的server层的，与存储引擎无关，只要设置开启了binlog日志，就可以进行记录  
redoLog 与 undoLog是Innodb存储引擎层的日志

在具体讲每个日志作用前，先整体理解一下事务执行的过程：
举例：状态1：A 10 B 10 --> 状态2：A 0 B 20 小A向小B转账10元  
整个事务的执行过程如下：  
T1：从磁盘中读取数据A到内存中（bufferpool）  
T2：记录数据到undolog（undolog不会落盘）  
T3：A-10  
T4：记录redolog 到redolog buffer  
T5：从磁盘读取数据B到内存中（bufferpool）  
T6：记录数据到undolog  
T7：B+10  
T8：记录redolog 到redolog buffer，server层标记prepare，说明准备提交（阶段1）  
T9：binlog写入磁盘  
T10：事务提交。redolog在server标记commit状态  
如果中途失败，将根据undolog进行

>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/事务执行过程.jpeg) 



1、binLog 二进制日志  
（1）基础信息
binLog主要用于主从复制，数据恢复
binLog记录数据库所有的写操作（增删改）日志信息，以二进制的形式保存在磁盘中。binlog是mysql的逻辑日志，是由mysql server层进行记录，使用任何存储引擎的mysql数据库都会记录binLog日志

逻辑日志：可以简单理解为记录的就是sql语句。

物理日志：因为mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更。

binlog是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志

（2）binLog的使用场景
binlog的使用场景主要有两个：

1）主从复制：主从复制模型中，要达到主从数据一致性，可以通过binlog来实现。在master端开启binlog，然后将binlog发送到各个slave端，在slave端重放binlog，从而达到数据一致性

2）数据恢复：通过使用mysqlbinlog工具来恢复数据。  
附：使用binlog进行数据恢复大致过程：cnblogs.com/YCcc/p/10825870.html
有两种方式：
第一种：通过start-stop point点恢复数据
我们找出在离误操作数据前，最近的一次备份信息，并找到当时备份前/后，flush binlog后，重新生成的binlog二进制文件，假设为mysql-bin.000582
通过备份文件先将数据恢复至备份时的数据，flush binlog，重新生成新的二进制日志文件，保证此后的操作，均写入新的日志文件中，mysql-bin.000582则不会再写入任何新的日志信息

查找mysql-bin.000582中所有写操作，通过begin找到start point，commit找到end point,根据start point与end point执行相关命令，恢复这个区间操作的数据
以此类推，边恢复数据，边查阅数据，直至恢复到最终数据


第二种：通过时间来进行数据恢复
依旧需要借助于备份文件以及产生的日志文件
根据数据产生异常时的前后时间点，进行数据恢复

这两种方法，都可以进行数据恢复，第二种更加简单，但是需要记住数据执行的具体时间点，第一种，则通过判断操作类型，根据start stop point来进行数据恢复，操作上更加复杂


（3）binlog刷盘时机（数据写入磁盘）
对于Innodb这个存储引擎而言，只有在事务提交时，才会记录binlog日志，在事务提交之前，是不会记录binlog日志的，那么binlog被记录后，什么时候才会将数据写入磁盘呢（刷盘）？
mysql通过sync_binlog参数，控制binlog的刷盘时机，取值范围：0-N
0：由系统判断什么时候刷盘(依赖于 OS 刷盘机制)
1：每次commit时都要将binlog刷入磁盘
N：每N个事务commit后，才会将binlog刷盘

从上面可以看出，sync_binlog最安全的是设置是1，这也是MySQL 5.7.7之后版本的默认值。
但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。


（4）binlog日志格式
在mysql5.7.7之前，binlog的默认日志格式STATEMENT，MySQL 5.7.7 之后，默认值是 ROW 日志格式通过 binlog-format 指定。
====================================================================================================================================================================  
binlog格式	            描述	                                    优点	                                            缺点
====================================================================================================================================================================  
STATEMENT       SQL语句的复制	                            日志文件小，减少了日志量，节约了IO,提高了性能            准确性差，对一些系统行数不能准确复制，例如：now()、uuid()	
====================================================================================================================================================================  
ROW	            基于行的复制，只记录每行实际数据的变更	        准确性强，能够准确复制数据的变更	                    产生的日志文件较大（尤其是一些alter的操作）
====================================================================================================================================================================  
MIXED	        基于STATMENT和ROW两种模式的混合复制	        准确性强、文件大小适中	                                有可能发生主从不一致的现象
====================================================================================================================================================================  


binlog有这么功能后，为什么还需要redolog和undolog呢，他们各自的作用又是什么呢？

2、redolog
我们都知道，事务的四大特性里面有一个是持久性，具体来说就是只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态。
那么mysql是如何保证一致性的呢？最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：
因为Innodb是以页为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！
一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！

因此mysql设计了redo log，具体来说就是只记录事务对数据页做了哪些修改，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。

（1）redolog的基本概念
redolog中包含两个部分：日志缓冲区 redolog buffer（位于内存中）；日志文件 redolog file（位于磁盘中）
WAL：对于执行的每一条DML语句，都会先写入redolog buffer，然后在某个时间点，再刷进redolog file中，这种先写buffer，再刷入磁盘的操作，就是mysql中常说的WAL(Write-Ahead Log)技术


在计算中，用户空间（user space）下的缓冲区是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。
因此，redo log buffer写入redo log file实际上是先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file中，过程如下

>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/redolog存储过程.png) 

mysql支持三种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数配置，各参数值含义如下：
>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/redolog参数值设置.png) 
>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/redolog参数设置图示.png) 

（2）redolog的记录形式
前面说过，redo log实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此redo log实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。如下图：
>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/redolog的记录形式.png) 

同时我们很容易得知，在innodb中，既有redo log需要刷盘，还有数据页也需要刷盘，redo log存在的意义主要就是降低对数据页刷盘的要求。
在上图中，write pos表示redo log当前记录的LSN(逻辑序列号)位置，check point表示数据页更改记录刷盘后对应redo log所处的LSN(逻辑序列号)位置。
write pos到check point之间的部分是redo log空着的部分，用于记录新的记录；check point到write pos之间是redo log待落盘的数据页更改记录。
当write pos追上check point时，会先推动check point向前移动，空出位置再记录新的日志。
启动innodb的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为redo log记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如binlog)要快很多。
重启innodb时，首先会检查磁盘中数据页的LSN，如果数据页的LSN小于日志中的LSN，则会从checkpoint开始恢复。
还有一种情况，在宕机前正处于checkpoint的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的LSN大于日志中的LSN，
这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。

（3）redolog有binlog的日志区别
>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/redolog有binlog的日志区别.png) 

由binlog和redo log的区别可知：binlog日志只用于归档，只依靠binlog是没有crash-safe能力的。
但只有redo log也不行，因为redo log是InnoDB特有的，且日志上的记录落盘后会被覆盖掉。因此需要binlog和redo log二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。

3、undo log
在Mysql里数据每次修改前，都首先会把修改之前的数据作为历史保存一份到undo log里面的，数据里面会记录操作该数据的事务ID，然后我们可以通过事务ID来对数据进行回滚。
全局空间中的undolog只服务于服务器运行时的回滚，并不是宕机恢复的必要条件。undolog的存在避免了redolog的IO操作，从而提高性能。

数据库事务四大特性中有一个是原子性，具体来说就是 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。
实际上，原子性底层就是通过undo log实现的。undo log主要记录了数据的逻辑变化，比如一条INSERT语句，对应一条DELETE的undo log
对于每个UPDATE语句，对应一条相反的UPDATE的undo log，这样在发生错误时，就能回滚到事务之前的数据状态。同时，undo log也是MVCC(多版本并发控制)实现的关键


undolog存在意义？
服务器运行时的回滚rollback、MVCC（多版本控制）就是基于此log

在内存中，不会进行刷盘；和宕机数据恢复没有关系。

减少IO提高回滚效率；

记录内容：可以看MVCC的实现，版本链内容

redolog的意义在于？
持久化，宕机恢复数据；

mysql为了提高性能，修改buffer pool中数据，后台IO线程实现内存和磁盘同步。执行update时，更新完内存就返回。

问题：宕机时，事务在内存中完成；但是同步只完成部分；那么就出现了数据不一致问题。

记录内容：物理日志，记录物理块的修改。

为了解决宕数据不一致问题，引入redolog。

WAL（write_ahead logging）技术指的就是刷盘前先记录到redolog中。
保证宕机情况下事务一致性；避免事务提交造成多个不连续物理页写入磁盘。
事务执行过程，内存更新循环写入logbuffer的redolog，标记prpare，进行一阶段刷盘。这样以来要么全部刷盘要么都不刷盘。一次IO同时避免了宕机事务不一致。

binlog意义在于？
binlog 的主要使用场景有两个，分别是主从复制和数据恢复。mysql服务器集群自带主从复制（Replication）方式。
简单来说就是slaver会开启IO线程是的relaylog和binlog同步，然后sql线程解析执行sql语句实现最终一致性。


三、事务

事务及其ACID属性

事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。

原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。
隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。
持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

事务的四个级别：
（1）读未提交（脏读）
会读取到未提交的信息

（2）读已提交（不可重复读）
同一个事务，多次读取数据，会发现前后读取的数据不一致
A读取数据，B也读取数据，此时他们读取的数据是一致的
B对数据进行更新并提交，此时A读取数据，就是被更新后的数据
前后不一致，此为不可重复读

（3）可重复读（幻读）
A事务读取数据，B读取数据，此时数据是一致的
A新增一条数据并提交，B读取的数据前后不一致，幻读

（4）序列化（效率较低）

数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大，因为事务隔离本质上就是使事务在一定程度上串行化，
需要根据具体的业务需求来决定使用哪种隔离级别