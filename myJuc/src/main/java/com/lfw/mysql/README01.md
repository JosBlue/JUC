一、使用profiles,performance_schema性能

1、一条sql语句从客户端到mysql服务端执行所要经历过程   
一条sql语句，在客户端上被编辑好后，点击执行，会经历以下过程：  
（1）客户端连接mysql服务端  
（2）连接服务后，在数据库服务端，就进入分析器，sql会被进行语法分析以及词法分析，会判断当前sql是否符合mysql的语法规则，符合规则后，再将sql进行词法分析，提取拆分关键词信息，比如where，from等
拆分这些关键词，组成AST（抽象语法树）  
（3）经历过分析器后，就进入优化器，会进行sql优化，整个优化主要由两个部分，分别为RBO和RCO，即基于规则优化，或者基于成本（代价）进行优化  
（4）sql优化完成后，就会进入执行器，执行器将其与底层的存储引擎一起，执行sql  

我们的sql优化，主要就是在分析器和优化器中进行

注：8.0之后，mysql中就没有缓存了，命中太低，没有太大的实际意义

>>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/sql执行过程.png) 

2、性能监控

（1）show profiles  
show profiles 完整显示一个sql每个步骤执行的时间，可以根据每个步骤的执行时间，进行分析判断，慢sql具体是慢在哪里的
（但是在企业应用中，通常情况下，这个值在研发所能看到的客户端是无法设置的，系统参数只可读）

在官网中，给出了show profiles会被逐渐被淘汰，推荐使用show performance schema(开启会在一定程度上，会影响到系统的性能)

（2）performance schema
performance schema的特点及作用：
>>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/performance_schema.png) 


performance schema其中包含了87张表  
show VARIABLES LIKE  'performance_SCHEMA' 查看当前变量是否开启（默认开启 on）
想要修改对应设置，需要到其配置文件中进行修改

performance schema表中的数据不会持久化到磁盘上，只会被记录在内存中，因此一旦服务器重启，这些数据就会丢失

那么performance schema有什么用呢？  
当我们发现我们的数据库执行sql比较慢，我们分析我们的sql没有发现什么问题，通过执行计划分析后没看出啥问题，就可以通过performance schema查看执行线程的信息，
查看每个线程执行了多长时间，具体做了什么事，占用了多少资源，并以此判断是否存在相关sql占用资源过多过长等情况。


mysql-2个概念
>>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/mysql-2个概念.png) 


（3）show PROCESSLIST  
查看当前的mysql服务一共有多少个连接



3、Schema与数据类型的优化  
===》1）数据类型优化  
a.更小的通常更好  
在满足实际业务需求时，选择能够正确存取数据的最小数据类型，通常能够带来更加高效的查询效率。因为更小的数据类型，占用更少的磁盘、内存和CPU缓存，
并且处理时，需要的CPU周期也更少。

b.简单就好（该是什么类型就是什么类型）  
这个的理解就是咱们存储数据时，该使用什么类型就使用什么数据类型，并且保障在满足业务需求的前提下，选择更加简单的数据类型，带来的效果更好  
比如：  
整型相对于字符串类型，操作的代价更低。因为字符集和校对规则，使得字符串相对于整型更加复杂  
使用mysql的自建类型存储时间，而不是使用字符串进行存储（在设置不同的数据类型时，所对应的查询时间是不一样的）  
用整型存储IP地址  
在mysql中对于IP转化，提供了一个函数  
select INET_ATON(192.168.2.168)==>将ip转化为整型值  
select INET_NTOA(123234) ==> 将整型值转换为IP地址  
存储IP时，我们使用整型这个数据类型进行存储，相对于使用字符串类型，可以节省存储空间，并且可以对IP的有效性进行校验，比如是否超过最大IP值，
但是可读性降低了

c.尽可能避免使用null  
对于这个问题，需要从多个角度进行看待  
首先，尽可能避免使用null，也就是将列的值设置为not null,为什么要这么做呢？  
因为如果使用null,存在null列，会使得mysql的优化变得更加复杂，比如索引，索引统计和值比较等都变得更加复杂  
所以，在有些字段，可以被设置为not null时，可以考虑设置为not null  
但是这么处理，在实际的业务场景中，也会存在一些问题，有些值根据业务属性而言，是可能为null的，并且，如果设置为not null，在代码的复杂度上会有所增加

d.实际细则  
（1）整型类型  
对于整型类型，应当选择尽量小的数据类型

（2）用于存储字符或字符串数据的类型  
可用于存储字符串数据的类型，在mysql中，通常可以使用如下4中数据类型进行存储  
字符型（char）  
字符串类型（varchar）  
BLOB  
TEXT  

字符型与字符串类型（char varchar）  
varchar与char都可以存储字符串，但是两者是有一定区别的，相对而言，使用的场景也不太一样
varchar没有固定的最大长度，可根据实际的字符串长度进行定义
char的最大长度是固定的，255，因此需要考虑实际的需求，是否会超过255

由于char的最大长度是固定的，不可变，因此在检索，写效率上，相对于varchar要更快一些，空间换时间
char会自动删除末尾的空格，varchar则不会

因此，varchar适合存储一些字符串数据长度波动比较大的数据，比如有长有短的文章  
char则适合存储一些长度比较固定的数据，比如身份证号等

varchar适合字符串很少更新的场景，每次更新后，都会重新计算并使用额外的存储空间保存长度  
char则适合字符串更新比较频繁，但长度比较固定的数据

varchar适合存储多字节的字符，比如汉字，特殊字符等

BLOB与TEXT  
mysql把每个BLOB和TEXT值当作一个独立的对象进行处理  
两者的设计都是为了存储很大数据量  
分别采用二进制和字符方式进行存储  


（3）时间类型 datetime & timestamp & date  
他们的区别，主要体现在两个方面  
1）占用字节数的大小  
datetime 占用8个字节  
timestamp 占用4个字节  
date 占用3个字节  

2）精确度不一样  
datetime 精确到毫秒 可保存的时间返回比较大（1000-9999）  
timestamp 精确到秒 时间范围（1970-01-01到2038-01-19）  

附：时间类型：timestamp 
我们知道，这个时间类型只到2038年，为什么呢？
是因为timestamp的底层使用的占4个字节的int类型存储的，int类型的范围是正负21亿，时间戳换算过来，刚好是1970-2038年这样的一个时间范围

3）和数据库设置时区的关系  
在跨国际的一些也去当中，不同时区是一个不得不考虑的问题  
datetime 不受数据库设置的时区的影响  
timestamp 依赖数据库设置的时区  

4）其他区别    
timestamp采用整型进行存储    
date可以使用日期函数，进行日期之间的计算  
date、datetime用于保存1000-01-01到9999-12-31之间的日期  


注意：不要使用字符串保存时间，占用空间大，并且无法使用mysql自带的时间函数


===》2）合理使用的范式和反范式  
三范式最初的存在目的，减少数据冗余  

根据业务实际需求，合理使用范式和反范式  


===》3）主键的选择  
主键主要分为两类：  
代理主键：与业务完全无关，唯一id  
自然主键：与业务关联，比如我们的身份证号  
推荐使用代理主键，不与业务耦合，并且统一主键，可以制定统一的主键规则


===》4）字符集的选择  
关于字符集，我们通常选择utf8，还有一种是utf8mb4  
utf8 可用于存储字符，特殊字符会存在乱码，只能存储2个字符的中文，超过2个就会出现乱码  
utf8mb4 适用于存储中文,中文可能是两个，或者三个字符  

如果我们确定不需要存储多语言的字符，那么我们没有必要非要选择utf8或者其他unicode字符类型，因为这样会造成存储空间的浪费  
纯拉丁字符，可选择latinl字符类型


===》5）存储引擎的选择  

不同的存储引擎，表示数据文件的组织形式不同

不设置，默认的存储引擎是innodb(配置文件中选择了)  
InnoDB与MyIsam的区别
>>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/InnoDB与MyIsam.png) 

非聚簇索引：索引文件与数据文件不放在一起
聚簇索引：索引文件与数据文件放在一起

InnoDB默认情况下，是给索引加锁的  
查询条件列如果是建的索引列，那么就会使用行锁，否则就会使用表锁  


===》6） 适当的数据冗余  
空间换时间

===》7）适当的数据拆分  
当我们的表中存在类似于TEXT或者很大的varchar字符串时，如果每次我们查询数据时，这个字段并不是我们需要查询出的数据，那么这个字段就应当被拆分到其他表中
进行存储，这样可以减少我们常用数据所占用的存储空间，每个数据块中可以存储的数据条数可以大大增加，减少物理IO的次数。  

分库分表：  
垂直切分：按照业务对数据模块分开存储  
水平切分：按照0-1000，1000-2000这样的方式切分存储