Image-01:

一、 Redis基本类型：String 类型(字符串，数值，bitMap)

1、注01：
下面所有k1,默认值：k1 Hello world
对于字符串的操作：
（1）Set命令：其中有set nx 以及 set xxset k1 111 nx:当 k1不存在时，将会新增，否则不会进行任何操作（可用于分布式锁）
xx：只能更新
nx：只能新建

（2）get命令不备注了


（3）append命令：追加命令，可以在k对应的value值后追加
如：append k1 " world"
通过get k1，输出：hello world

（4）SETRANG命令：字符串截取设置
我们替换world为liufuwei: SETRANG k1 6 liufuwei (6表示偏移量，即从哪里开始替换)

（5）GETRANG命令：字符串截取，
截取"world":GETRANG k1 6 10  这样就可截取出world
注意：正反向索引：这里还存在反向下标：字符串从后往前，world的最后一个字母(d)的下标是 -1，前一个字母（l）的下标为-2，以此类推
因此，截取"world"还可以直接:GETRANG k1 6 -1   这样也可截取出world

（6）STRLEN：取出字符串的长度，直接STRLEN k1,对于hello world的值为11，注意，中间空格是要算的

2、通过type key：可以查看key的类型
如：type k1:String

3、注02：二进制安全
redis是二进制安全的，不会去破坏你原有语言的编码，底层存的就是按照字节来存储的（HBase也是二进制安全的）
二进制安全：在redis与外界客户端进行交互的时候，只要双方客户端有统一的编解码，那么数据就不会被破坏，这就是二进制安全
与二进制安全相对应的就是encoding
因此咱们在多语言开发中，更喜欢用xml或JSON字符串来进行交互，而不是使用序列化的信息来进行交互，就是因为不同语言对一些信息的存储的字节
长度是不一致的，转换的过程中就会存在一些问题

4、其他比较重要的命令：
（1）GETSET：
在String类型中，存在GETSET这种命令，其实这种命令是没有必要存在的，但是之所以设计它，是因为他可以减少一次命令操作，减少对应一次IO
操作，这也体现了redis设计者的细腻行。 
（2）MSETNX：
msetNx，即set nx 的批量操作，可以设置多组，msetNx k1 a k2 b;这个命令也是原子性的，即k1,k2是同时成功同时失败的，只有k1,k2均
不存在的时候，才能设置成功
对应取操作：MGET k1 k2

5、BitMap 注03：setbit
(1)setbit key offset value 
offset表示二进制位的偏移量,8位==》1字节，见下图
![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/redis-bitMap.png)   
 
操作：
1> setbit k1 1 1; 
此时k1的值为：01000000，对应ASCALL码值为：@
如果执行strlen k1；值为1。这是因为当前值处于8位当中，只有1个字节

2>setbit k1 7 1;
此时k1的值为：01000010，对应ASCALL码值为：A
如果执行strlen k1；值为1。这是因为当前值依旧处于8位当中，只有1个字节

3>setbit k1 9 1;
此时k1的值为：01000010 01000000，对应ASCALL码值为：A@，redis在解析时。满8位就会解析
如果执行strlen k1；值为2。此时位2字节
 
6、BitMap其他命令：
1) bitpos key bit [start] [end]
start 与 end表示字节的起始与结束位置；如k1 = 01000000 01000000
如：bitpos k1 1 0 0 ;表示取k1 第一个字节中的第一次出现1的偏移量，（0 0 表示取第一个字节）；观察k1的构成，返回偏移量值为：1
如：bitpos k1 1 1 1;表示取k1 第二个字节中的第一次出现1的偏移量（1 1 表示取第二个字节）；观察k1的构成，返回偏移量值为：9、
如：bitpos k1 1 0 1;表示取k1 前两个字节中，第一次出现1的偏移量，观察k1的构成，返回偏移量的值为：1

2）bitcount key  [start end] 
start 与 end 表示字节的起始与结束；count表示1出现的次数
如：bitcount k1 0 1;表示取k1中，前两个字节中，出现1的次数，观察k1，值为2

3）bitop operation destkey [key...]
operation 表示按位"与"或"非"操作
destkey 表示目标key
[key...] 表示参与操作的key
如：k1= 01000001(等于A)；  k2= 01000010(等于B)
操作：
1）bitop and andKey k1 k2;
输出结果：@
k1与k2位按位与操作，即有0为1，同时为1则为1，按位与后的值为：01000000，值为@

2）bitop or orKey k1 k2;
输出结果：C
k1与k2位按位或操作，即有1为1，同时为0则为0，按位或后的值为：00000011，值为C

7、bitMap非常有用的几种场景：（注04）（注05）
1）用户系统，统计用户的登陆天数，且统计用户登陆窗口随机 

思路：
<1>如果使用传统的关系型数据库进行设计，mysql,那么我们记录一条数据，大概会需要：
自增id（BIGINT 8字节）；
用户id(BIGINT 8字节)；
登陆时间（TIMESTAMP 4字节）；
状态（TINYINT 1字节）；
那么一天一条数据就需要：8+8+4+1=21字节
一年365天，就需要：365*21/1024 约等于7.5M，这是一个用户的数据，电商系统的用户量比较多时，就会存储空间不够，并且会因为数据量过大导致查询过慢

<2>使用redis中String类型的BitMap进行存储
8位为1个字节，那么1个字节就可以表示8天，，一年365/366天，我们直接使用400位，即400/8=50字节表示
也就是说，一个用户，一年的数据，大概就是50个字节就可以表示（实际是46个字节）
操作：
如：用户在第8天登陆：setbit userId 7 1；（注意下标是从0开始的，因此第8天，就是7）
如：用户在第365天登陆：setbit userId 364 1；
统计用户在最近16天内登陆的次数：BITCOUNT -2 -1;(此处使用的反向索引)

注意：此处不仅仅是节省空间，还能极大的提升查询的效率，相对于使用mysql需要进行IO,计算等，直接通过读取二进制码的效率是十分快的

1）统计一定时间范围内的活跃用户数（详情看图） 