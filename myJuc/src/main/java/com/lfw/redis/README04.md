1、命令：
（1）nc localhost 6379
与6379端口的redis建立一个socket链接

（2）echo -e "set k1 99\nincr k1\nget k1" | nc localhost 6379
通过管道的方式，通过socket链接批量执行这些命令，echo -e 即输出信息，并可识别\n为换行符
管道的优势：可以让通信的成本更低

2、redis的冷加载
在redis中将大量数据写入

3、pub/sub
需要先监听，才能收到pub发布的消息

pub/sub使用场景：
类似于微信这种社交聊天类的工具
pub/sub用于实时聊天的控制
sorted_set可用于查阅历史消息，使用时间作为key，聊天内容作为value进行存储，sorted_set本身又是根据key由小到大进行排列的
因此直接顺序取即可

注意：通过上诉方式，进行查阅实时消息及查阅历史消息，可能存在一些问题
比如，消息pub后，sub到消息后，结果客户端挂了，sorted_set未获取到消息，那么在查阅历史消息时，就可能发现少一条消息，从而导致
数据不一致的情况

可以通过开启3个客户端，同时接受不了pub消息，一个sub，一个放在sorted_set中，还有一个接收后，放在kafka中，然后存储在DB中
详细见图


4、redis的事务(详细见图)
<1>mutli:开启事务
<2>EXEC：执行，如果执行失败，所有命令都将失败
注意：由于redis是单线程的，因此，他会一条一条地去处理，因此，哪个先到达exec，就会先执行，可能就会对后续的一些操作产生影响

<3>watch：监控（乐观锁）：观察对应key的值，若被修改，则后续执行失败


5、redis中的布隆过滤器--可解决缓存穿透问题（重要）有图见图
缓存穿透：有些数据在缓存中及数据库中均不在，但是又一直在查询这些数据，那么由于缓存中不存在，所以这些请求都会被打到数据库上，让数据库
去承担这些压力，这就是缓存穿透

布隆过滤器的实现思路：
<1>首先你有什么数据，你有什么数据，就通过你的定义的相关函数将这些数据进行hash计算，
映射到二进制位图（bitmap）中的某个位置，并将其修改为1

<2>当外部元素进行数据查找时，就通过相同的函数进行hash运算，通过计算出的位置，到二进制位图上去找，如果对应位置为1，那么表明这个信息是存在于
你的缓存或者数据库当中的

<3>如果找到对应的位为1，那么表明这个数据是存在于对应缓存或者数据库中的，如果为0，则表示当前数据并不存在，直接返回或者做出其他预设操作；
通过以上这些操作，就避免了一些不存在于咱们系统中的数据，穿透缓存，给数据库造成压力

注意，布隆过滤器，有一定概率，导致一些不存在于系统中的数据，也通过计算后，被放行进来，这就是误标记 
之所以存在这些情况，是因为经过hash运算后，可能存在一些hash冲突的情况，这就导致一些不存在于系统的数据，也被放进来了，但这种情况是比较少的

布隆过滤器，将这些放在逻辑放在哪里，根据自己的业务情况进行选择
将布隆过滤器这些全放在redis一侧，整个业务架构会比较轻量级，但是redis这个模块会比较复杂
将这些逻辑全放在业务层进行处理，那么整个系统的设计上就会显得臃肿一些，redis会比较轻量级

注意：关于穿透及布隆过滤器
对于数据不存在，穿透了缓存，在client端，需要增加redis中的key,value标记
如果数据库增加了元素，也需要完成元素对boolm的添加

注：了解布谷鸟过滤器


6、redis作为数据库与缓存的区别：
可以得出一些结论：
<1>缓存中的数据"不重要"
<2>缓存中的数据不是全量数据
<3>缓存中的数据，应该随着访问变化（热数据）

那么用redis作为缓存，redis中的数据怎么能随着业务的变化，只保留热数据呢？（只保留热数据，是因为内存大小有限，也就是有瓶颈）
根据业务逻辑，来更新淘汰缓存信息
淘汰规则主要有两种：
LRU：最近最少使用（多久没碰它）
LFU：最少使用（碰了多少次）
详细见redis官网，需要将常见的几种淘汰规则理解

关于redis key的有效期，关注几个问题：
<1>redis的过期时间会随着访问延长？ 不会！！
<2>redis的key对应的信息，如果发生了写操作，会剔除过期时间(换句话说，redis没有延续时间这种概念)
<3>redis的可以的过期时间为倒计时，redis不能延长这个时间
<4>redis的可以的过期时间也可以为定时过期
<5>redis的key过期时间，根据自己的实际业务逻辑进行设置

7、redis如何淘汰过期的keys
主要有两种：
<1>key被动访问时判断key是否过期
<2>周期轮询判断是否过期（增量）
详细查看官网：redis.cn

使用这些过期规则的目的：稍微牺牲一下redis的内存，保住redis的性能为王！！！

