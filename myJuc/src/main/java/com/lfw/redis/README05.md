缓存常见问题：击穿、雪崩、穿透、一致性（双写）

1、redis作为缓存/数据库
作为缓存时，数据理论上允许丢失的==》需要追求极速
作为数据库时，数据时绝对不能丢的==》需要满足持久化+速度（但掉电易丢失数据）

2、单机持久化
存储层做持久化有两种方式：
快照/副本：即一定时间，将内存/磁盘中的数据拷贝一份，就可将数据回滚到上次快照的时间

日志：所有的增删改操作，都进行日志记录。那么即使快照/副本都没有，也可以根据日志文件进行数据回滚

redis中的两种持久化方式：
<1> RDB（快照/副本）
RDB的特点：时点性（即某一时刻的数据）
时点混乱的问题（见图）

知识补充：Linux 管道 ｜
管道的作用
<1>衔接：前一个命令的输出作为后一个命令的输入
<2>管道会触发创建一个【子进程】

echo $$ | more:获取当前进程的父id，输出也为当前父进程的id
echo $BASHPID | more:echo $BASHPID也可以获取当前进程的父id,但此时输出的是子进程的id
注意：
$$ 的优先级是高于 ｜（管道）的
 
关于Linux中父子进程：
父进程中的变量，子进程是否可以看到？
常规思想：父进程与子进程之间是有数据隔离的
进阶思想：父进程其实可以让子进程看到数据！

附：./test.sh &(让执行程序后台执行)

Linux中，export的环境变量，子进程的修改，不会破坏父进程；同时，父进程的修改，也不会破坏子进程

通过这个父子进程的关系，咱们可以推导出，如果在redis中，主进程继续处理各种数据处理，再创建出一个子进程，进行数据备份，由于父子进程对于数据的修改各不可见，那么就可以实现快照（RDB）的功能了
如果按照这个思路来进行，那么需要考虑两个问题：
1.创建子进程的速度快慢
2.内存空间大小（内存空间够不够） 

对于上诉问题，在Linux中，有一个系统调用fork();
fork()对于速度及内存空间占用问题：
速度：相对较快 ==> copy on write(解决创建速度快)
空间占用：相对较小 （指针）

因此：redis中的RDB，整体做法，就是在要创建快照的那一时刻，系统调用，fork出一个子进程，由于内核机制是采用的copy on write这种机制，所以速度非常快，进行数据快照操作，在这之后，父子进程，对数据的修改，是相互看不到的，因此相互不影响，
也因此，redis的RDB的特点是：时点性，即数据就是创建出子进程进程的那一刻的数据

对于copy on write:
即fork出一个子进程时，拷贝的是指针，有任何的修改，就是对指针的修改

了解完上诉信息，那么redis的RDB要落一个时点性的数据，是怎么实现的呢？
<1>人为触发命令：
1、save：前台触发，会阻塞redis的其他交互
2、bgsave：后台触发，会fork子进程，不会阻塞

相对而言，使用save命令，是非常明确的目的，比如关机维护的时候，所以还是有一定的应用场景

<2>配置文件中给出bgsave的规则（配置文件中是save这个标识，但是触发的是bgsave）
图：redis-bgsave配置文件

解释：save 60 10000：表示达到60s或者操作数达到10000了，就会触发一次RDB 

图：redis-RDB配置文件02
dbfilename:设置存储文件的名称
dir:设置文件存储的位置


RDB的缺点（弊端）：
<1>不支持拉链：只有一个dump.rdb文件。（也就是说当达到设定值之后，就会生成一个RDB文件，需要人为手动去拷贝处理，但是这种方式不占用内存空间）
<2>丢失数据相对多一些，时点与时点之间窗口容易丢失，(如8点进行数据dump，9点再进行数据dump，那么在8点到9点之间，若redis挂了，就可能存在数据丢失的情况）

优点：
RDB类似java中的序列化，恢复速度相对快



<2>AOF（日志 Append only file）
redis的写操作，记录到日志文件中

优点：
<1>丢失数据相对较少
<2>redis中，可以同时开启RDB和AOF(注意：如果开启了AOF,只会用AOF的方式进行恢复，因为它的数据相对完整一些)
在redis4.0以后，AOF包含RDB全量，增加新的记录写数据(RDB+AOF)

弊端：
1.体量会无限变大==》随之而来的，就是恢复慢

<3>结合AOF及RDB各自的优缺点进行优化：

1、redis4.0以前，AOF主要的优化，就是重写，即抵消与整合命令，删除抵消的命令，合并重复的命令（最终也是一个纯指令的日志文件）

2、redis4.0之后，也是重写，但是有区别：重写的时候，先将老的数据RDB到AOF文件中，然后将增量的信息以指令的方式Append到AOF中，所以此时，AOF是一个混合体，利用了RDB的快，以及AOF日志全的特点
文件结构就是：[RDB File][AOF tail]

重写触发的规则配置：
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
即当aof文件大小到64mb，或者达到100%时，就会触发重写


<4>回到原点：redis是一个内存数据库
由于redis是一个内存数据库，因此它的写操作，会触发IO，同时也可能存在丢失数据的可能，在其配置文件中，默认存在三个级别：
appendfsync on/always/everysec
NO: 等待缓冲区满了，系统自动将信息刷进磁盘（这种可能会丢失一个buffer大小的数据）

ALAWAYS: 每次写操作，都将信息刷进磁盘（这种可能丢失一条数据，大概4K）

EVERYSEC:每秒将信息刷进磁盘(这种可能丢失介于no与alawys之间大小的数据)==》这也是默认设置









