Redis集群：主从复制、CAP、PAXS


1、单机、单机点、单实例会存在哪些问题
（1）单点故障
（2）容量有限
（3）单机压力很大

那么这些问题怎么去解决？
（1）单点故障：
AKF（许多单点问题，都可以往这个上面去引）即X，Y，Z轴（见图）

X轴：全量，镜像
沿X轴做全量镜像，解决单点故障问题
但是无法解决容量有限的问题，因为时候全量镜像，即每个机器的数据是一致的，并且大小也是固定的
压力问题这块，集群一般是主备等方式，主上可进行读写操作，但是从上只能读操作，所以写的压力还是很大

Y轴：业务、功能
沿Y轴，根据不同业务或功能等，进行数据拆分存储，解决容量有限的问题

Z轴：优先级、逻辑再拆分
沿Z轴，对同一个redis中的数据，按照一定的规则进行分开存储（可以理解为mysql中的同一业务数据进行分表存储），让一个单点的数据量足够小，
数据存储量小，单机被访问时，压力也相对较小


但是，按照上述的拆分方式，也还是会存在一些问题：
因为通过AKF,一变多，就会存在数据一致性的问题！！！

一、那么数据一致性的问题怎么解决？有以下几种解决方案：

1、强一致性：所有节点阻塞，直到数据全部一致
存在的问题：破坏可用性
redis使用集群，即一变多的初衷，就是为了解决可用性的问题，但若使用强一致性，反而会破坏可用性，这违背最初的设计初衷，因此这种方案除非在
及其特殊的场景下使用，否则在企业级应用中，均不会采用此种方案。

2、弱一致性：通过异步方式提高可用性，但需要容忍一部分数据丢失

3、最终一致性：通过异步+消息中间件，保证数据的最终一致性，可以使用消息中间件，主redis与消息中间件保持同步阻塞，并且保证消息中间件的高可用，响应速度够快，从而保证数据的最终一致性


由于是最终一致性，所以有可能取到不一致的数据，但是可以强调成：强一致性

理解了上面的这些理论，下面我们先来理解两个概念：主从与主备的区别
主从：主从这种方式，通常主可读写，从仅可读，即从也会参与业务

主备：主备这种方式，通常主可读写，但是备却不会参与业务，只是作为主的一个备份

理解了主从与主备，可以看到，这两个都有主，那么对于主，就会存在一些问题：单点问题
由于主存在单点的问题，因此，在企业中，我们通常会针对主做高可用（HA）
高可用的最终目的，就是当主机宕机后，备或从能够成为主，对外表现是系统没有出问题，因此HA的目的并不是让主不挂。

HA(高可用)的实现方式：
1、人为解决（不够可靠）
2、自动故障转移（代替人）
代替人===》了解人是怎么监控的？===》通过一个技术，使用程序实现===》只要是一个程序，那么就会存在单点故障问题===》解决单点故障，那就做成一个一变多的集群来解决
感觉回到了最初的原点，其实他们还是有些区别的

我们看看这种区别在哪里：
比如：
有三台机器监控我们的redis是否宕机，反过来想，就是判断状态的问题
如果需要三台监控机器都给出提示，说redis已经挂了，这种方式，就是我们之前提到的强一致性了===》根据我们之前的知识，强一致性是会破坏可用性的，在分布式下也是难以实现的，因此不适用

既然强一致性不适用，那么我们就直接一部分提示redis挂了，就说redis挂了，可以理解为上面提到的弱一致性，但是注意，这是有区别的
一部分的关键，是到底需要几个提示redis挂了才能确认redis挂了？？

如果是1个就可以确认的情况下：统计是不准确的，或者说不够势力范围
同时，会产生一个问题：网络分区，也被称为脑裂；一个服务，访问却出现多种答案，让外界感觉到数据不一致了。

因此，为什么很多这种问题，都要求数量需要过半，就是为了防止会出现脑裂的问题。
但是注意：并不是出现脑裂就代表不好，这个得看分区容忍性来判断，如在一批注册服务当中，只要一个服务可用就行，也就是说即使这个集群中其他服务都挂了，但是只要有一台能够通信就可以

如果是2个就可以确认的情况下：不就存在中间状态，并且拥有了自己的势力范围，成功解决脑裂的问题

结合图中的推导，可以得出以下结论：
在有n台机器的集群中，需要n/2+1台机器给出一致结论，提示主挂了，那么才能认为主挂了，就是我们通常说的需要过半

那么为什么我们我们搭建集群的时候，一般都会选择奇数台机器？
奇数台比其更大的偶数台成本更低
其次，就是奇数台相对于比起更大的偶数台，机器出现问题的可能性更小
因此，根据经验，一般都会选择奇数台机器来搭建集群。


CAP原则：
C:数据一致性
A:可用性
P:分区容错性
在分布式环境下，只能满足其二

对于redis的主从复制：
Redis使用默认的异步复制，其特点是低延迟和高性能

具体的实现，如果不是十分清楚其中的逻辑，建议重新看一遍视频（1:24:15开始看）
总结：
REPLICAOF 主的IP 主的端口号：即可将当前机器设置为从，并且指定追随的主

REPLICAOF no one:将当前机器从'从'机中脱离出来，不追随任何主机，既不为从机，也不为主机

从追随主后，会同步复制所有主的数据，并刷掉自己原有的数据
在从机同步主机的数据过程中，在同步的过程中，是否允许外部连接访问从机读取数据？
可通过配置项：replica-server-stable-data yes/no
yes:允许（默认允许）
no:不允许
>![avatar](/Users/liufuwei/Documents/my-project/my-juc/JUC/myJuc/image/redis-replica-server.png)


replica-read-only yes:表示备机是否只支持查询，还是要开启写入权限 （默认只读）
repl-diskless-sync no:同步时，可以先落数据到磁盘，再通过网络IO进行同步；也可以直接通过网络IO发送RDB文件进行传输同步（默认为no,即先落磁盘，再网络传输） 
repl-blacklog-size 1mb:主机中有一个同步队列，这个就是设置这个队列的大小的，和RDB同步有关，如RDB同步时，偏移量为8，则直接从8开始同步数据，做增量更新；但是如果队列满了，8这个偏移量已经
不存在了，那么这个时候由于取不到8，就会做一个全量同步更新，因此需要根据实际的业务场景，来设置这个队列大小 

min-replicas-to-write 3:最少需要几个从写成功（默认是注释掉了，因为这个值没设置好，会导致主从复制变为强一致性了）
max-replicas-max-lag 10:默认也是被注释掉了

redis的主从复制，如果从挂了，那么会怎么办？
redis的主从复制是增量更新的
RDB文件中，存在增量更新的id号；但是在AOF文件中却是不存在的 
换句话说，在从同步主的数据时，如果从挂了之后重启，并且是通过RDB方式进行数据同步的，那么由于在RDB中，会记录从之前追随的主是哪台机器，并且其中记录了一个replicaof Id，那么从在重启进行数据同步
时，就可以从这个replicaof Id对应的位置，进行增量更新
但是在AOF文件中，却是不存在这样的id的 
所以，主从复制如果开启了AOF，那么就是全量同步

redis的主从复制，如果主挂了，那么会怎么办？
注意：在主上，可以知道在主上，有多少从追随它

下面，我们开始了解主的高可用设计（注意查阅官网:redis.cn/topics/sentinel.html ）==》哨兵
哨兵的作用：监控、提醒、以及 自动故障转移
哨兵通过redis的发布/订阅，可以监控主的所有从机以及所有哨兵
详细见图 

注意：主从复制这种方式，只是redis做集群的一种实现方式，他可以解决redis单点故障问题，以及一定程度上解决单点压力过大的问题，但是无法解决单点容量有限的问题（沿X轴做扩展）
要解决单点容量有限的问题，可已通过集群分片这种方式，将不同数据落在不同的漕点上， 详细见下一个README07.md


 




